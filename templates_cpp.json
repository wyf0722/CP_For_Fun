{
  "Copypasta_Cpp": {
    "generate_snippets.py": "import os\nimport json\nimport sys\nimport argparse\n\n# 获取当前脚本所在的目录\nscript_dir = os.path.dirname(os.path.realpath(__file__))\n\n# 设置命令行参数\nparser = argparse.ArgumentParser(description=\"Generate VSCode snippets from source files.\")\nparser.add_argument(\n    \"-d\", \"--directory\", type=str, default=\".\",\n    help=\"Relative directory to search for source files (default: current script's directory)\"\n)\nparser.add_argument(\n    \"-e\", \"--extensions\", type=str, nargs='+', default=[\"cpp\"],\n    help=\"List of file extensions to create snippets from (default: ['cpp'])\"\n)\nparser.add_argument(\n    \"-o\", \"--output\", type=str, default=\"cpp.json\",\n    help=\"Output file for the generated snippets (default: cpp.json)\"\n)\n\nargs = parser.parse_args()\n\n# 将输入目录转换为相对于脚本目录的绝对路径\nsearch_dir = os.path.abspath(os.path.join(script_dir, args.directory))\n\nsnippets = {}\n\n# # Walk through the specified directory\n# for subdir in os.walk(search_dir):\n#     # Ignore hidden directories and .git\n#     if subdir[0].startswith('.') or '.git' in subdir[0]:\n#         continue\n\n#     # Process each file in the current directory\n#     for filename in subdir[2]:\n#         # Split file name and extension\n#         name, extension = os.path.splitext(filename)\n#         extension = extension.lstrip('.')  # Remove dot from extension for comparison\n        \n#         # Skip files without the specified extensions\n#         if extension not in args.extensions:\n#             continue\n\n#         # Check for duplicate snippets\n#         if name in snippets:\n#             print(f'Error: Duplicate snippet {name}', file=sys.stderr)\n#             sys.exit(1)\n\n#         # Read the file and create a snippet\n#         path = os.path.join(subdir[0], filename)\n#         with open(path, 'r', encoding='utf-8') as f:\n#             snippet = {\n#                 \"prefix\": name,\n#                 \"body\": [line.rstrip() for line in f.readlines()],\n#                 \"description\": name\n#             }\n#             snippets[name] = snippet\n\n#         print(f'Generated snippet for {name}', file=sys.stderr)\n\n# Walk through the specified directory recursively to find files in all levels of subdirectories\nfor root, dirs, files in os.walk(search_dir):\n    # 忽略 .git 目录及隐藏目录（.开头的文件夹）\n    dirs[:] = [d for d in dirs if not d.startswith('.') and d != '.git']\n\n    # Process each file in the current directory\n    for filename in files:\n        # Split file name and extension\n        name, extension = os.path.splitext(filename)\n        extension = extension.lstrip('.')  # Remove dot from extension for comparison\n        \n        # Skip files without the specified extensions\n        if extension not in args.extensions:\n            continue\n\n        # Check for duplicate snippets\n        if name in snippets:\n            print(f'Error: Duplicate snippet {name}', file=sys.stderr)\n            sys.exit(1)\n\n        # Read the file and create a snippet\n        path = os.path.join(root, filename)\n        with open(path, 'r', encoding='utf-8') as f:\n            snippet = {\n                \"prefix\": name,\n                \"body\": [line.rstrip() for line in f.readlines()],\n                \"description\": f\"Snippet for {name}\"\n            }\n            snippets[name] = snippet\n\n        print(f'Generated snippet for {name}', file=sys.stderr)\n\n\n# Write snippets to the specified output file\nwith open(args.output, 'w', encoding='utf-8') as f:\n    f.write(json.dumps(snippets, indent=2))\n\nprint('Snippets generation completed', file=sys.stderr)\n"
  },
  "Graph": {
    "BFS.cpp": "/**\n * https://github.com/Joshc88/CPTemplates/blob/main/Graph/bfs.h\n * directed: True(有向图) False(无向图)\n*/\ntemplate <bool directed = true> struct BFS { // 0 or 1-indexed, doesn't matter\n    int n;\n    vector<vector<int>> edges;\n\n    BFS() {}\n\n    BFS(int N) {\n        n = N;\n        edges.resize(n+1);\n    }\n\n    void add_edge(int from, int to) {\n        edges[from].push_back(to);\n        if (!directed) edges[to].push_back(from);\n    }\n\n    vector<int> dist(vector<int> sources) {\n        vector<int> res(n+1, -1);\n        queue<int> q;\n        for (int i : sources) {\n            res[i] = 0;\n            q.push(i);\n        }\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            for (int i : edges[cur]) {\n                if (res[i] == -1) {\n                    res[i] = res[cur]+1;\n                    q.push(i);\n                }\n            }\n        }\n        return res;\n    }\n\n    int dist(int source, int dest) {\n        return dist({source})[dest];\n    }\n\n    pair<int, vector<int>> path(int source, int dest) {\n        vector<int> res(n+1, -1);\n        vector<int> before(n+1);\n        queue<int> q;\n        res[source] = 0;\n        q.push(source);\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            for (int i : edges[cur]) {\n                if (res[i] == -1) {\n                    res[i] = res[cur]+1;\n                    before[i] = cur;\n                    q.push(i);\n                }\n            }\n        }\n        if (res[dest] == -1) return make_pair(-1, vector<int>());\n        vector<int> path = {dest};\n        while (path.back() != source) path.push_back(before[path.back()]);\n        reverse(path.begin(), path.end());\n        return make_pair(res[dest], path);\n    }\n};",
    "Tarjan.cpp": "// 无向图tarjan\nint n, t;\nvector<vector<int>> g(n);\nvector<int> dfn(n), low(n);\nvector<vector<int>> bridges;\n\nvoid tarjan(int x, int fa) {\n    dfn[x] = low[x] = ++t;\n    for (int y : g[x]) {\n        if (y == fa)\n            continue;\n        if (!dfn[y]) {\n            tarjan(y, x);\n            low[x] = min(low[x], low[y]);\n            if (dfn[x] < low[y]) {\n                bridges.push_back({x, y});\n            }\n        } else {\n            low[x] = min(low[x], dfn[y]);\n        }\n    }\n}",
    "dijkstra.cpp": "/**\n * https://github.com/the-tourist/algo/blob/master/graph/dijkstra.cpp\n*/\ntemplate <typename T>\nclass graph {\n   public:\n    struct edge {\n        int from;\n        int to;\n        T cost;\n    };\n\n    vector<edge> edges;\n    vector<vector<int>> g;\n    int n;\n\n    graph(int _n) : n(_n) { g.resize(n); }\n\n    virtual int add(int from, int to, T cost) = 0;\n};\n\n// 有向图\ntemplate <typename T>\nclass digraph : public graph<T> {\n   public:\n    using graph<T>::edges;\n    using graph<T>::g;\n    using graph<T>::n;\n\n    digraph(int _n) : graph<T>(_n) {}\n\n    int add(int from, int to, T cost = 1) {\n        assert(0 <= from && from < n && 0 <= to && to < n);\n        int id = (int)edges.size();\n        g[from].push_back(id);\n        edges.push_back({from, to, cost});\n        return id;\n    }\n\n    digraph<T> reverse() const {\n        digraph<T> rev(n);\n        for (auto& e : edges) {\n            rev.add(e.to, e.from, e.cost);\n        }\n        return rev;\n    }\n};\n\n// 无向图\ntemplate <typename T>\nclass undigraph : public graph<T> {\n   public:\n    using graph<T>::edges;\n    using graph<T>::g;\n    using graph<T>::n;\n\n    undigraph(int _n) : graph<T>(_n) {}\n\n    int add(int from, int to, T cost = 1) {\n        assert(0 <= from && from < n && 0 <= to && to < n);\n        int id = (int)edges.size();\n        g[from].push_back(id);\n        g[to].push_back(id);\n        edges.push_back({from, to, cost});\n        return id;\n    }\n};\n\ntemplate <typename T>\nvector<T> dijkstra(const graph<T>& g, int start) {\n    assert(0 <= start && start < g.n);\n    vector<T> dist(g.n, numeric_limits<T>::max());\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> s;\n    dist[start] = 0;\n    s.emplace(dist[start], start);\n    while (!s.empty()) {\n        T expected = s.top().first;\n        int i = s.top().second;\n        s.pop();\n        if (dist[i] != expected) {\n            continue;\n        }\n        for (int id : g.g[i]) {\n            auto& e = g.edges[id];\n            int to = e.from ^ e.to ^ i;\n            if (dist[i] + e.cost < dist[to]) {\n                dist[to] = dist[i] + e.cost;\n                s.emplace(dist[to], to);\n            }\n        }\n    }\n    return dist;\n    // returns numeric_limits<T>::max() if there's no path\n}"
  },
  "Utils": {
    "Modnum.cpp": "// @link: https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp\n\ntemplate <typename T> T mod_inv_in_range(T a, T m) {\n\t// assert(0 <= a && a < m);\n\tT x = a, y = m;\n\t// coeff of a in x and y\n\tT vx = 1, vy = 0;\n\twhile (x) {\n\t\tT k = y / x;\n\t\ty %= x;\n\t\tvy -= k * vx;\n\t\tstd::swap(x, y);\n\t\tstd::swap(vx, vy);\n\t}\n\tassert(y == 1);\n\treturn vy < 0 ? m + vy : vy;\n}\n\ntemplate <typename T> struct extended_gcd_result {\n\tT gcd;\n\tT coeff_a, coeff_b;\n};\ntemplate <typename T> extended_gcd_result<T> extended_gcd(T a, T b) {\n\tT x = a, y = b;\n\t// coeff of a and b in x and y\n\tT ax = 1, ay = 0;\n\tT bx = 0, by = 1;\n\twhile (x) {\n\t\tT k = y / x;\n\t\ty %= x;\n\t\tay -= k * ax;\n\t\tby -= k * bx;\n\t\tstd::swap(x, y);\n\t\tstd::swap(ax, ay);\n\t\tstd::swap(bx, by);\n\t}\n\treturn {y, ay, by};\n}\n\ntemplate <typename T> T mod_inv(T a, T m) {\n\ta %= m;\n\ta = a < 0 ? a + m : a;\n\treturn mod_inv_in_range(a, m);\n}\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tint v;\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = mod_inv_in_range(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv -= MOD-o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(int64_t(v) * int64_t(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\ntemplate <typename U, typename V> struct pairnum {\n\tU u;\n\tV v;\n\n\tpairnum() : u(0), v(0) {}\n\tpairnum(long long val) : u(val), v(val) {}\n\tpairnum(const U& u_, const V& v_) : u(u_), v(v_) {}\n\n\tfriend std::ostream& operator << (std::ostream& out, const pairnum& n) { return out << '(' << n.u << ',' << ' ' << n.v << ')'; }\n\tfriend std::istream& operator >> (std::istream& in, pairnum& n) { long long val; in >> val; n = pairnum(val); return in; }\n\n\tfriend bool operator == (const pairnum& a, const pairnum& b) { return a.u == b.u && a.v == b.v; }\n\tfriend bool operator != (const pairnum& a, const pairnum& b) { return a.u != b.u || a.v != b.v; }\n\n\tpairnum inv() const {\n\t\treturn pairnum(u.inv(), v.inv());\n\t}\n\tpairnum neg() const {\n\t\treturn pairnum(u.neg(), v.neg());\n\t}\n\tpairnum operator- () const {\n\t\treturn pairnum(-u, -v);\n\t}\n\tpairnum operator+ () const {\n\t\treturn pairnum(+u, +v);\n\t}\n\n\tpairnum& operator ++ () {\n\t\t++u, ++v;\n\t\treturn *this;\n\t}\n\tpairnum& operator -- () {\n\t\t--u, --v;\n\t\treturn *this;\n\t}\n\n\tpairnum& operator += (const pairnum& o) {\n\t\tu += o.u;\n\t\tv += o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator -= (const pairnum& o) {\n\t\tu -= o.u;\n\t\tv -= o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator *= (const pairnum& o) {\n\t\tu *= o.u;\n\t\tv *= o.v;\n\t\treturn *this;\n\t}\n\tpairnum& operator /= (const pairnum& o) {\n\t\tu /= o.u;\n\t\tv /= o.v;\n\t\treturn *this;\n\t}\n\n\tfriend pairnum operator ++ (pairnum& a, int) { pairnum r = a; ++a; return r; }\n\tfriend pairnum operator -- (pairnum& a, int) { pairnum r = a; --a; return r; }\n\tfriend pairnum operator + (const pairnum& a, const pairnum& b) { return pairnum(a) += b; }\n\tfriend pairnum operator - (const pairnum& a, const pairnum& b) { return pairnum(a) -= b; }\n\tfriend pairnum operator * (const pairnum& a, const pairnum& b) { return pairnum(a) *= b; }\n\tfriend pairnum operator / (const pairnum& a, const pairnum& b) { return pairnum(a) /= b; }\n};\n\ntemplate <typename tag> struct dynamic_modnum {\nprivate:\n#if __cpp_inline_variables >= 201606\n\t// C++17 and up\n\tinline static int MOD_ = 0;\n\tinline static uint64_t BARRETT_M = 0;\n#else\n\t// NB: these must be initialized out of the class by hand:\n\t//   static int dynamic_modnum<tag>::MOD = 0;\n\t//   static int dynamic_modnum<tag>::BARRETT_M = 0;\n\tstatic int MOD_;\n\tstatic uint64_t BARRETT_M;\n#endif\n\npublic:\n\t// Make only the const-reference public, to force the use of set_mod\n\tstatic constexpr int const& MOD = MOD_;\n\n\t// Barret reduction taken from KACTL:\n\t/**\n\t * Author: Simon Lindholm\n\t * Date: 2020-05-30\n\t * License: CC0\n\t * Source: https://en.wikipedia.org/wiki/Barrett_reduction\n\t * Description: Compute $a \\% b$ about 5 times faster than usual, where $b$ is constant but not known at compile time.\n\t * Returns a value congruent to $a \\pmod b$ in the range $[0, 2b)$.\n\t * Status: proven correct, stress-tested\n\t * Measured as having 4 times lower latency, and 8 times higher throughput, see stress-test.\n\t * Details:\n\t * More precisely, it can be proven that the result equals 0 only if $a = 0$,\n\t * and otherwise lies in $[1, (1 + a/2^64) * b)$.\n\t */\n\tstatic void set_mod(int mod) {\n\t\tassert(mod > 0);\n\t\tMOD_ = mod;\n\t\tBARRETT_M = (uint64_t(-1) / MOD);\n\t}\n\tstatic uint32_t barrett_reduce_partial(uint64_t a) {\n\t\treturn uint32_t(a - uint64_t((__uint128_t(BARRETT_M) * a) >> 64) * MOD);\n\t}\n\tstatic int barrett_reduce(uint64_t a) {\n\t\tint32_t res = int32_t(barrett_reduce_partial(a) - MOD);\n\t\treturn (res < 0) ? res + MOD : res;\n\t}\n\n\tstruct mod_reader {\n\t\tfriend std::istream& operator >> (std::istream& i, mod_reader) {\n\t\t\tint mod; i >> mod;\n\t\t\tdynamic_modnum::set_mod(mod);\n\t\t\treturn i;\n\t\t}\n\t};\n\tstatic mod_reader MOD_READER() {\n\t\treturn mod_reader();\n\t}\n\nprivate:\n\tint v;\n\npublic:\n\n\tdynamic_modnum() : v(0) {}\n\tdynamic_modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const dynamic_modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, dynamic_modnum& n) { int64_t v_; in >> v_; n = dynamic_modnum(v_); return in; }\n\n\tfriend bool operator == (const dynamic_modnum& a, const dynamic_modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const dynamic_modnum& a, const dynamic_modnum& b) { return a.v != b.v; }\n\n\tdynamic_modnum inv() const {\n\t\tdynamic_modnum res;\n\t\tres.v = mod_inv_in_range(v, MOD);\n\t\treturn res;\n\t}\n\tfriend dynamic_modnum inv(const dynamic_modnum& m) { return m.inv(); }\n\tdynamic_modnum neg() const {\n\t\tdynamic_modnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend dynamic_modnum neg(const dynamic_modnum& m) { return m.neg(); }\n\n\tdynamic_modnum operator- () const {\n\t\treturn neg();\n\t}\n\tdynamic_modnum operator+ () const {\n\t\treturn dynamic_modnum(*this);\n\t}\n\n\tdynamic_modnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tdynamic_modnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tdynamic_modnum& operator += (const dynamic_modnum& o) {\n\t\tv -= MOD-o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tdynamic_modnum& operator -= (const dynamic_modnum& o) {\n\t\tv -= o.v;\n\t\tv = (v < 0) ? v + MOD : v;\n\t\treturn *this;\n\t}\n\tdynamic_modnum& operator *= (const dynamic_modnum& o) {\n\t\tv = barrett_reduce(int64_t(v) * int64_t(o.v));\n\t\treturn *this;\n\t}\n\tdynamic_modnum& operator /= (const dynamic_modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend dynamic_modnum operator ++ (dynamic_modnum& a, int) { dynamic_modnum r = a; ++a; return r; }\n\tfriend dynamic_modnum operator -- (dynamic_modnum& a, int) { dynamic_modnum r = a; --a; return r; }\n\tfriend dynamic_modnum operator + (const dynamic_modnum& a, const dynamic_modnum& b) { return dynamic_modnum(a) += b; }\n\tfriend dynamic_modnum operator - (const dynamic_modnum& a, const dynamic_modnum& b) { return dynamic_modnum(a) -= b; }\n\tfriend dynamic_modnum operator * (const dynamic_modnum& a, const dynamic_modnum& b) { return dynamic_modnum(a) *= b; }\n\tfriend dynamic_modnum operator / (const dynamic_modnum& a, const dynamic_modnum& b) { return dynamic_modnum(a) /= b; }\n};\n\ntemplate <typename T> struct mod_constraint {\n\tT v, mod;\n\n\tfriend mod_constraint operator & (mod_constraint a, mod_constraint b) {\n\t\tif (a.mod < b.mod) std::swap(a, b);\n\t\tif (b.mod == 1) return a;\n\n\t\textended_gcd_result<T> egcd = extended_gcd<T>(a.mod, b.mod);\n\t\tassert(a.v % egcd.gcd == b.v % egcd.gcd);\n\n\t\tT extra = b.v - a.v % b.mod;\n\t\textra /= egcd.gcd;\n\n\t\textra *= egcd.coeff_a;\n\t\textra %= b.mod / egcd.gcd;\n\t\textra += (extra < 0) ? b.mod / egcd.gcd : 0;\n\n\t\treturn mod_constraint{\n\t\t\ta.v + extra * a.mod,\n\t\t\ta.mod * (b.mod / egcd.gcd)\n\t\t};\n\t}\n};\n\nusing Z = modnum<1'000'000'007>;\n",
    "Mint.cpp": "using i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nusing u128 = unsigned __int128;\n\ntemplate<class T>\nconstexpr T power(T a, u64 b, T res = 1) {\n    for (; b != 0; b /= 2, a *= a) {\n        if (b & 1) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\ntemplate<u32 P>\nconstexpr u32 mulMod(u32 a, u32 b) {\n    return u64(a) * b % P;\n}\n\ntemplate<u64 P>\nconstexpr u64 mulMod(u64 a, u64 b) {\n    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;\n    res %= P;\n    return res;\n}\n\nconstexpr i64 safeMod(i64 x, i64 m) {\n    x %= m;\n    if (x < 0) {\n        x += m;\n    }\n    return x;\n}\n\nconstexpr std::pair<i64, i64> invGcd(i64 a, i64 b) {\n    a = safeMod(a, b);\n    if (a == 0) {\n        return {b, 0};\n    }\n    \n    i64 s = b, t = a;\n    i64 m0 = 0, m1 = 1;\n\n    while (t) {\n        i64 u = s / t;\n        s -= t * u;\n        m0 -= m1 * u;\n        \n        std::swap(s, t);\n        std::swap(m0, m1);\n    }\n    \n    if (m0 < 0) {\n        m0 += b / s;\n    }\n    \n    return {s, m0};\n}\n\ntemplate<std::unsigned_integral U, U P>\nstruct ModIntBase {\npublic:\n    constexpr ModIntBase() : x(0) {}\n    template<std::unsigned_integral T>\n    constexpr ModIntBase(T x_) : x(x_ % mod()) {}\n    template<std::signed_integral T>\n    constexpr ModIntBase(T x_) {\n        using S = std::make_signed_t<U>;\n        S v = x_;\n        v %= S(mod());\n        if (v < 0) {\n            v += mod();\n        }\n        x = v;\n    }\n    \n    constexpr static U mod() {\n        return P;\n    }\n    \n    constexpr U val() const {\n        return x;\n    }\n    \n    constexpr ModIntBase operator-() const {\n        ModIntBase res;\n        res.x = (x == 0 ? 0 : mod() - x);\n        return res;\n    }\n    \n    constexpr ModIntBase inv() const {\n        return power(*this, mod() - 2);\n    }\n    \n    constexpr ModIntBase &operator*=(const ModIntBase &rhs) & {\n        x = mulMod<mod()>(x, rhs.val());\n        return *this;\n    }\n    constexpr ModIntBase &operator+=(const ModIntBase &rhs) & {\n        x += rhs.val();\n        if (x >= mod()) {\n            x -= mod();\n        }\n        return *this;\n    }\n    constexpr ModIntBase &operator-=(const ModIntBase &rhs) & {\n        x -= rhs.val();\n        if (x >= mod()) {\n            x += mod();\n        }\n        return *this;\n    }\n    constexpr ModIntBase &operator/=(const ModIntBase &rhs) & {\n        return *this *= rhs.inv();\n    }\n    \n    friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase &rhs) {\n        lhs *= rhs;\n        return lhs;\n    }\n    friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase &rhs) {\n        lhs += rhs;\n        return lhs;\n    }\n    friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase &rhs) {\n        lhs -= rhs;\n        return lhs;\n    }\n    friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase &rhs) {\n        lhs /= rhs;\n        return lhs;\n    }\n    \n    friend constexpr std::istream &operator>>(std::istream &is, ModIntBase &a) {\n        i64 i;\n        is >> i;\n        a = i;\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const ModIntBase &a) {\n        return os << a.val();\n    }\n    \n    friend constexpr std::strong_ordering operator<=>(ModIntBase lhs, ModIntBase rhs) {\n        return lhs.val() <=> rhs.val();\n    }\n    \nprivate:\n    U x;\n};\n\ntemplate<u32 P>\nusing ModInt = ModIntBase<u32, P>;\ntemplate<u64 P>\nusing ModInt64 = ModIntBase<u64, P>;\n\nstruct Barrett {\npublic:\n    Barrett(u32 m_) : m(m_), im((u64)(-1) / m_ + 1) {}\n\n    constexpr u32 mod() const {\n        return m;\n    }\n\n    constexpr u32 mul(u32 a, u32 b) const {\n        u64 z = a;\n        z *= b;\n        \n        u64 x = u64((u128(z) * im) >> 64);\n        \n        u32 v = u32(z - x * m);\n        if (m <= v) {\n            v += m;\n        }\n        return v;\n    }\n\nprivate:\n    u32 m;\n    u64 im;\n};\n\ntemplate<u32 Id>\nstruct DynModInt {\npublic:\n    constexpr DynModInt() : x(0) {}\n    template<std::unsigned_integral T>\n    constexpr DynModInt(T x_) : x(x_ % mod()) {}\n    template<std::signed_integral T>\n    constexpr DynModInt(T x_) {\n        int v = x_;\n        v %= int(mod());\n        if (v < 0) {\n            v += mod();\n        }\n        x = v;\n    }\n    \n    constexpr static void setMod(u32 m) {\n        bt = m;\n    }\n    \n    static u32 mod() {\n        return bt.mod();\n    }\n    \n    constexpr u32 val() const {\n        return x;\n    }\n    \n    constexpr DynModInt operator-() const {\n        DynModInt res;\n        res.x = (x == 0 ? 0 : mod() - x);\n        return res;\n    }\n    \n    constexpr DynModInt inv() const {\n        auto v = invGcd(x, mod());\n        assert(v.first == 1);\n        return v.second;\n    }\n    \n    constexpr DynModInt &operator*=(const DynModInt &rhs) & {\n        x = bt.mul(x, rhs.val());\n        return *this;\n    }\n    constexpr DynModInt &operator+=(const DynModInt &rhs) & {\n        x += rhs.val();\n        if (x >= mod()) {\n            x -= mod();\n        }\n        return *this;\n    }\n    constexpr DynModInt &operator-=(const DynModInt &rhs) & {\n        x -= rhs.val();\n        if (x >= mod()) {\n            x += mod();\n        }\n        return *this;\n    }\n    constexpr DynModInt &operator/=(const DynModInt &rhs) & {\n        return *this *= rhs.inv();\n    }\n    \n    friend constexpr DynModInt operator*(DynModInt lhs, const DynModInt &rhs) {\n        lhs *= rhs;\n        return lhs;\n    }\n    friend constexpr DynModInt operator+(DynModInt lhs, const DynModInt &rhs) {\n        lhs += rhs;\n        return lhs;\n    }\n    friend constexpr DynModInt operator-(DynModInt lhs, const DynModInt &rhs) {\n        lhs -= rhs;\n        return lhs;\n    }\n    friend constexpr DynModInt operator/(DynModInt lhs, const DynModInt &rhs) {\n        lhs /= rhs;\n        return lhs;\n    }\n    \n    friend constexpr std::istream &operator>>(std::istream &is, DynModInt &a) {\n        i64 i;\n        is >> i;\n        a = i;\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const DynModInt &a) {\n        return os << a.val();\n    }\n    \n    friend constexpr std::strong_ordering operator<=>(DynModInt lhs, DynModInt rhs) {\n        return lhs.val() <=> rhs.val();\n    }\n    \nprivate:\n    u32 x;\n    static Barrett bt;\n};\n\ntemplate<u32 Id>\nBarrett DynModInt<Id>::bt = 998244353;\n\nusing Z = ModInt<1000000007>;\n",
    "tensor.cpp": "template <typename T, int NDIMS>\nstruct tensor_view {\n    static_assert(NDIMS >= 0, \"NDIMS must be nonnegative\");\n\n   protected:\n    std::array<int, NDIMS> shape;\n    std::array<int, NDIMS> strides;\n    T* data;\n\n    tensor_view(std::array<int, NDIMS> shape_,\n                std::array<int, NDIMS> strides_,\n                T* data_)\n        : shape(shape_), strides(strides_), data(data_) {}\n\n   public:\n    tensor_view() : shape{0}, strides{0}, data(nullptr) {}\n\n   protected:\n    int flatten_index(std::array<int, NDIMS> idx) const {\n        int res = 0;\n        for (int i = 0; i < NDIMS; i++) {\n            res += idx[i] * strides[i];\n        }\n        return res;\n    }\n    int flatten_index_checked(std::array<int, NDIMS> idx) const {\n        int res = 0;\n        for (int i = 0; i < NDIMS; i++) {\n            assert(0 <= idx[i] && idx[i] < shape[i]);\n            res += idx[i] * strides[i];\n        }\n        return res;\n    }\n\n   public:\n    T& operator[](std::array<int, NDIMS> idx) const {\n#ifdef FAN_DEBUG\n        return data[flatten_index_checked(idx)];\n#else\n        return data[flatten_index(idx)];\n#endif\n    }\n    T& at(std::array<int, NDIMS> idx) const {\n        return data[flatten_index_checked(idx)];\n    }\n\n    template <int D = NDIMS>\n    typename std::enable_if<(0 < D), tensor_view<T, NDIMS - 1>>::type\n    operator[](int idx) const {\n        std::array<int, NDIMS - 1> nshape;\n        std::copy(shape.begin() + 1, shape.end(), nshape.begin());\n        std::array<int, NDIMS - 1> nstrides;\n        std::copy(strides.begin() + 1, strides.end(), nstrides.begin());\n        T* ndata = data + (strides[0] * idx);\n        return tensor_view<T, NDIMS - 1>(nshape, nstrides, ndata);\n    }\n    template <int D = NDIMS>\n    typename std::enable_if<(0 < D), tensor_view<T, NDIMS - 1>>::type at(\n        int idx) const {\n        assert(0 <= idx && idx < shape[0]);\n        return operator[](idx);\n    }\n\n    template <int D = NDIMS>\n    typename std::enable_if<(0 == D), T&>::type operator*() const {\n        return *data;\n    }\n\n    template <typename U, int D>\n    friend struct tensor_view;\n    template <typename U, int D>\n    friend struct tensor;\n};\n\ntemplate <typename T, int NDIMS>\nstruct tensor {\n    static_assert(NDIMS >= 0, \"NDIMS must be nonnegative\");\n\n   protected:\n    std::array<int, NDIMS> shape;\n    std::array<int, NDIMS> strides;\n    int len;\n    T* data;\n\n   public:\n    tensor() : shape{0}, strides{0}, len(0), data(nullptr) {}\n\n    explicit tensor(std::array<int, NDIMS> shape_, const T& t = T()) {\n        shape = shape_;\n        len = 1;\n        for (int i = NDIMS - 1; i >= 0; i--) {\n            strides[i] = len;\n            len *= shape[i];\n        }\n        data = new T[len];\n        std::fill(data, data + len, t);\n    }\n\n    tensor(const tensor& o)\n        : shape(o.shape), strides(o.strides), len(o.len), data(new T[len]) {\n        for (int i = 0; i < len; i++) {\n            data[i] = o.data[i];\n        }\n    }\n\n    tensor& operator=(tensor&& o) noexcept {\n        using std::swap;\n        swap(shape, o.shape);\n        swap(strides, o.strides);\n        swap(len, o.len);\n        swap(data, o.data);\n        return *this;\n    }\n    tensor(tensor&& o) : tensor() { *this = std::move(o); }\n    tensor& operator=(const tensor& o) { return *this = tensor(o); }\n    ~tensor() { delete[] data; }\n\n    using view_t = tensor_view<T, NDIMS>;\n    view_t view() { return tensor_view<T, NDIMS>(shape, strides, data); }\n    operator view_t() { return view(); }\n\n    using const_view_t = tensor_view<const T, NDIMS>;\n    const_view_t view() const {\n        return tensor_view<const T, NDIMS>(shape, strides, data);\n    }\n    operator const_view_t() const { return view(); }\n\n    T& operator[](std::array<int, NDIMS> idx) { return view()[idx]; }\n    T& at(std::array<int, NDIMS> idx) { return view().at(idx); }\n    const T& operator[](std::array<int, NDIMS> idx) const {\n        return view()[idx];\n    }\n    const T& at(std::array<int, NDIMS> idx) const { return view().at(idx); }\n\n    template <int D = NDIMS>\n    typename std::enable_if<(0 < D), tensor_view<T, NDIMS - 1>>::type\n    operator[](int idx) {\n        return view()[idx];\n    }\n    template <int D = NDIMS>\n    typename std::enable_if<(0 < D), tensor_view<T, NDIMS - 1>>::type at(\n        int idx) {\n        return view().at(idx);\n    }\n\n    template <int D = NDIMS>\n    typename std::enable_if<(0 < D), tensor_view<const T, NDIMS - 1>>::type\n    operator[](int idx) const {\n        return view()[idx];\n    }\n    template <int D = NDIMS>\n    typename std::enable_if<(0 < D), tensor_view<const T, NDIMS - 1>>::type at(\n        int idx) const {\n        return view().at(idx);\n    }\n\n    template <int D = NDIMS>\n    typename std::enable_if<(0 == D), T&>::type operator*() {\n        return *view();\n    }\n    template <int D = NDIMS>\n    typename std::enable_if<(0 == D), const T&>::type operator*() const {\n        return *view();\n    }\n};\n\n// Usage:\n// tensor<T, NDIMS> t(shape, [initial_value])\n// t[{i1, i2, ..., iN}]\n// *t[i1][i2]...[iN]\n",
    "y_combinator.cpp": "/**\n * Description: wraps a lambda so it can call itself\n * Source: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\n */\n\nnamespace std {\n \ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n \n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n \ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n \n} // namespace std\n\nvoid y_comb_demo() {\n\tcout << y_combinator([](auto gcd, int a, int b) -> int {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t})(20,30) << \"\\n\"; // outputs 10\n}",
    "Discrete.cpp": "template <typename T>\nstruct Discrete {\n    Discrete() {}\n    void add(T t) { p.push_back(t); }\n\n    void init() {\n        sort(p.begin(), p.end());\n        p.resize(unique(p.begin(), p.end()) - p.begin());\n    }\n\n    int size() { return p.size(); }\n\n    int query(T t) { return lower_bound(p.begin(), p.end(), t) - p.begin(); }\n\n    T operator[](int id) { return p[id]; }\n\n    vector<T>& get() { return p; }\n    vector<T> p;\n};",
    "reverse_comparator.cpp": "template <typename F> struct reverse_comparator_t {\n\tF f;\n\ttemplate <typename Arg1, typename Arg2> constexpr bool operator() (Arg1&& arg1, Arg2&& arg2) & {\n\t\treturn f(std::forward<Arg2>(arg2), std::forward<Arg1>(arg1));\n\t}\n\ttemplate <typename Arg1, typename Arg2> constexpr bool operator() (Arg1&& arg1, Arg2&& arg2) const& {\n\t\treturn f(std::forward<Arg2>(arg2), std::forward<Arg1>(arg1));\n\t}\n\ttemplate <typename Arg1, typename Arg2> constexpr bool operator() (Arg1&& arg1, Arg2&& arg2) && {\n\t\treturn std::move(f)(std::forward<Arg2>(arg2), std::forward<Arg1>(arg1));\n\t}\n\ttemplate <typename Arg1, typename Arg2> constexpr bool operator() (Arg1&& arg1, Arg2&& arg2) const&& {\n\t\treturn std::move(f)(std::forward<Arg2>(arg2), std::forward<Arg1>(arg1));\n\t}\n};\n\ntemplate <typename F> constexpr reverse_comparator_t<std::decay_t<F>> reverse_comparator(F&& f) {\n\treturn { std::forward<F>(f) };\n}\n\n// for sort\nvector<int> v;\nauto cmp = [] (int x, int y) {\n    return x < y;\n};\nsort(v.begin(), v.end(), reverse_comparator(cmp));\n// for priority_queue\npriority_queue<int, vector<int>, decltype(reverse_comparator(cmp))> pq;"
  },
  "String": {
    "Trie.cpp": "/**\n * @link https://github.com/nealwu/competitive-programming/blob/master/strings/trie.cc\n*/\ntemplate <char MIN_CHAR = 'a', int ALPHABET = 26>\nstruct array_trie {\n    struct trie_node {\n        array<int, ALPHABET> child;\n        int words_here = 0, starting_with = 0;\n\n        trie_node() { memset(&child[0], -1, ALPHABET * sizeof(int)); }\n    };\n\n    static const int ROOT = 0;\n\n    vector<trie_node> nodes = {trie_node()};\n\n    array_trie(int total_length = -1) {\n        if (total_length >= 0)\n            nodes.reserve(total_length + 1);\n    }\n\n    int get_or_create_child(int node, int c) {\n        if (nodes[node].child[c] < 0) {\n            nodes[node].child[c] = int(nodes.size());\n            nodes.emplace_back();\n        }\n\n        return nodes[node].child[c];\n    }\n\n    int build(const string& word, int delta) {\n        int node = ROOT;\n\n        for (char ch : word) {\n            nodes[node].starting_with += delta;\n            node = get_or_create_child(node, ch - MIN_CHAR);\n        }\n\n        nodes[node].starting_with += delta;\n        return node;\n    }\n\n    int add(const string& word) {\n        int node = build(word, +1);\n        nodes[node].words_here++;\n        return node;\n    }\n\n    int erase(const string& word) {\n        int node = build(word, -1);\n        nodes[node].words_here--;\n        return node;\n    }\n\n    int find(const string& str) const {\n        int node = ROOT;\n\n        for (char ch : str) {\n            node = nodes[node].child[ch - MIN_CHAR];\n\n            if (node < 0)\n                break;\n        }\n\n        return node;\n    }\n\n    // Given a string, how many words in the trie are prefixes of the string?\n    int count_prefixes(const string& str, bool include_full) const {\n        int node = ROOT, count = 0;\n\n        for (char ch : str) {\n            count += nodes[node].words_here;\n            node = nodes[node].child[ch - MIN_CHAR];\n\n            if (node < 0)\n                break;\n        }\n\n        if (include_full && node >= 0)\n            count += nodes[node].words_here;\n\n        return count;\n    }\n\n    // Given a string, how many words in the trie start with the given string?\n    int count_starting_with(const string& str, bool include_full) const {\n        int node = find(str);\n\n        if (node < 0)\n            return 0;\n\n        return nodes[node].starting_with -\n               (include_full ? 0 : nodes[node].words_here);\n    }\n};",
    "StringHash随机模数.cpp": "// 随机模数\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint rnd(int x, int y) {\n    return uniform_int_distribution<int>(x, y)(rng);\n}\n\nint SINGLE_MOD = 998244353 + rnd(0, 1e9), SINGLE_BASE = 233 + rnd(0, 1e3);\n\n// 单模数\nstruct StringHash {\n    vector<long long> P, H;\n    int MOD, BASE;\n\n    StringHash() {}\n\n    StringHash(string &s, int m = SINGLE_MOD, int b = SINGLE_BASE) {\n        MOD = m;\n        BASE = b;\n        int n = s.size();\n        P.resize(n + 1);\n        P[0] = 1;\n        for (int i = 1; i <= n; i++) P[i] = P[i - 1] * BASE % MOD;\n        H.resize(n + 1);\n        H[0] = 0;\n        for (int i = 1; i <= n; i++) H[i] = (H[i - 1] * BASE + (s[i - 1] ^ 7)) % MOD;\n    }\n\n    // s[l, r]下标从1开始\n    long long query(int l, int r) {\n        return (H[r] - H[l - 1] * P[r - l + 1] % MOD + MOD) % MOD;\n    }\n};\n\n// 双模数\nint MOD1 = 998244353 + rnd(0, 1e9), BASE1 = 233 + rnd(0, 1e3);\nint MOD2 = 998244353 + rnd(0, 1e9), BASE2 = 233 + rnd(0, 1e3);\nstruct DoubleHash {\n    StringHash hash1, hash2;\n\n    DoubleHash(string &s) {\n        hash1 = StringHash(s, MOD1, BASE1);\n        hash2 = StringHash(s, MOD2, BASE2);\n    }\n\n    pair<long long, long long> query(int l, int r) {\n        return make_pair(hash1.query(l, r), hash2.query(l, r));\n    }\n};\n",
    "zFunction.cpp": "std::vector<int> zFunction(std::string s) {\n    int n = s.size();\n    std::vector<int> z(n + 1);\n    z[0] = n;\n    for (int i = 1, j = 1; i < n; i++) {\n        z[i] = std::max(0, std::min(j + z[j] - i, z[i - j]));\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n            z[i]++;\n        }\n        if (i + z[i] > j + z[j]) {\n            j = i;\n        }\n    }\n    return z;\n}",
    "KMP.cpp": "// j(n) = pi[j(n-1) - 1]\nvector<int> prefix_function(string s) {\n    int n = (int)s.length();\n    vector<int> pi(n);\n    for (int i = 1; i < n; i++) {\n        int j = pi[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = pi[j - 1];\n        if (s[i] == s[j])\n            j++;\n        pi[i] = j;\n    }\n    return pi;\n}\n\n// 在text中查找pattern的出现位置\nvector<int> find_occurrences(string text, string pattern) {\n    string cur = pattern + '#' + text;\n    int sz1 = text.size(), sz2 = pattern.size();\n    vector<int> v;\n    vector<int> lps = prefix_function(cur);\n    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {\n        if (lps[i] == sz2)\n            v.push_back(i - 2 * sz2);\n    }\n    return v;\n}",
    "StringHash自然溢出.cpp": "typedef unsigned long long ULL;\nconst int P = 131;\nconst int N = 100010;\nclass StringHash {\npublic:\n    ULL p[N], h[N];\n    int n;\n\n    StringHash(string s) {\n        n = s.size();\n        p[0] = 1;\n        h[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            h[i] = h[i - 1] * P + s[i - 1];\n            p[i] = p[i - 1] * P;\n        }\n    }\n    \n    // hash s[l, r] 注意下标从1开始!!!\n    ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; }\n\n    bool substr(int l1, int r1, int l2, int r2) {\n        return get(l1, r1) == get(l2, r2);\n    }\n};\n"
  },
  "template": {
    "IO_complex.cpp": "/*************************************************************************\n    > File Name: ${1:${TM_FILENAME}}\n    > Author: Wu YiFan\n    > Github: https://github.com/wyf0722\n    > Mail: wyf0722chosen@gmail.com\n    > Created Time: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}\n************************************************************************/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n \nvoid dbg_out() { cout << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cout << ' ' << H; dbg_out(T...); }\n#define debug(...) cout << '[' << __LINE__ << \"] (\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n\nusing i64 = long long;\nconst int inf = INT_MAX / 2 - 100;\nconst i64 infLL = LLONG_MAX / 3;\nconstexpr int MOD = 998244353; // 998244353 1000000007\nint dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};\ntemplate <class T> using V = vector<T>;\ntemplate<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T> using max_heap=priority_queue<T>;\n\nconstexpr int popcount(int x) { return __builtin_popcount(x); }\nconstexpr int topbit(int x) { return x == 0 ? 0 : 31 - __builtin_clz(x); }\n\ntemplate <class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }  // set a = min(a,b)\ntemplate <class T> bool chmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }  // set a = max(a,b)\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { ++hi; assert(lo <= hi); while (lo < hi) { T mid = lo + (hi - lo) / 2; f(mid) ? hi = mid : lo = mid + 1; } return lo; }\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) { --lo; assert(lo <= hi); while (lo < hi) { T mid = lo + (hi - lo + 1) / 2; f(mid) ? lo = mid : hi = mid - 1; } return lo; }\n\n#define MULTICASE 1\nvoid solve() {\n\n}\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int T = 1;\n#if MULTICASE\n    cin >> T;\n#endif\n    while (T--) {\n        solve();\n    }\n    return 0;\n}",
    "IO_simple.cpp": "/*************************************************************************\n    > File Name: ${1:${TM_FILENAME}}\n    > Author: Wu YiFan\n    > Github: https://github.com/wyf0722\n    > Mail: wyf0722chosen@gmail.com\n    > Created Time: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}\n************************************************************************/\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n \nvoid dbg_out() { cout << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cout << ' ' << H; dbg_out(T...); }\n#define debug(...) cout << '[' << ':' << __LINE__ << \"] (\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n\nusing i64 = long long;\n#define MULTICASE 1\nvoid solve() {\n\n}\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int T = 1;\n#if MULTICASE\n    cin >> T;\n#endif\n    while (T--) {\n        solve();\n    }\n    return 0;\n}"
  },
  "Math": {
    "Primes.cpp": "// https://github.com/Joshc88/CPTemplates/blob/main/Math/primes.h\nconst int MX = 1e5 + 10;\nstruct Primes {\n    vector<int> lpf, lpfcnt, primes, remaining;\n\n    Primes(int n) {\n        lpf.resize(n + 1);\n        lpfcnt.resize(n + 1);\n        remaining.resize(n + 1);\n        for (int i = 2; i <= n; i++) {\n            if (!lpf[i]) {\n                lpf[i] = i;\n                lpfcnt[i] = remaining[i] = 1;\n                primes.push_back(i);\n            }\n            for (int j = 0; i * primes[j] <= n; j++) {\n                int val = i * primes[j];\n                lpf[val] = primes[j];\n                lpfcnt[val] = lpfcnt[primes[j]] + (lpf[i] == primes[j] ? lpfcnt[i] : 0);\n                remaining[val] = (lpf[i] == primes[j]) ? remaining[i] : i;\n                if (primes[j] == lpf[i])\n                    break;\n            }\n        }\n    }\n\n    bool isprime(long long x) {\n        if (x < 2)\n            return false;\n        if (x < lpf.size())\n            return lpf[x] == x;\n        for (long long i = 2; i * i <= x; i++) {\n            if (!(x % i))\n                return false;\n        }\n        return true;\n    }\n\n    vector<pair<int, int>> factorise(int x) {\n        vector<pair<int, int>> factors;\n        for (; x > 1; x = remaining[x])\n            factors.emplace_back(lpf[x], lpfcnt[x]);\n        return factors;\n    }\n} primes(MX);",
    "Math.cpp": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\ni64 MOD = 1e9 + 7;\n/**\n * 埃氏筛\n */\nconst int MX = 1e5 + 10;\nvector<int> prime;\nvector<int> is_prime(MX + 1, 1);\nint init = []() -> int {\n    is_prime[0] = is_prime[1] = 0;\n    for (int i = 2; i <= MX; i++) {\n        if (is_prime[i]) {\n            prime.push_back(i);\n            for (int j = i; j <= MX / i; j++) {\n                is_prime[i * j] = 0;\n            }\n        }\n    }\n    return 0;\n}();\n\n/**\n * 线性筛\n */\nconst int MX = 1e5 + 10;\nvector<int> prime;\nvector<int> is_prime(MX + 1, 1);\nint init = []() -> int {\n    is_prime[0] = is_prime[1] = 0;\n    for (int i = 2; i <= MX; i++) {\n        if (is_prime[i]) prime.push_back(i);\n        for (int j = 0; i * prime[j] <= MX; j++) {\n            is_prime[i * prime[j]] = 0;\n            if (i % prime[j] == 0) break;\n        }\n    }\n    return 0;\n}();\n\n\n/**\n * 组合数（数量较小）\n */\n\ni64 C(i64 a, int b) {\n    i64 ans = 1LL;\n    for (int i = 1; i <= b; i++) {\n        ans = (ans * (a + 1 - i) / i) % MOD;\n    }\n    return ans;\n}\n\n/**\n * 快速幂\n*/\ni64 power(i64 a, int b) {\n    i64 ans = 1LL;\n    for (; b; b /= 2) {\n        if (b & 1) ans = (ans * a) % MOD;\n        a = a * a % MOD;\n    }\n    return ans;\n}\n\n",
    "Palindromic.cpp": "vector<int> pal;\nauto init = [] {\n    // 严格按顺序从小到大生成所有回文数（不用字符串转换）\n    for (int base = 1; base <= 10000; base *= 10) {\n        // 生成奇数长度回文数\n        for (int i = base; i < base * 10; i++) {\n            int x = i;\n            for (int t = i / 10; t; t /= 10) {\n                x = x * 10 + t % 10;\n            }\n            pal.push_back(x);\n        }\n        // 生成偶数长度回文数\n        if (base <= 1000) {\n            for (int i = base; i < base * 10; i++) {\n                int x = i;\n                for (int t = i; t; t /= 10) {\n                    x = x * 10 + t % 10;\n                }\n                pal.push_back(x);\n            }\n        }\n    }\n    return 0;\n}();\n",
    "Comb.cpp": "using u32 = unsigned;\nusing i64 = long long;\nusing u64 = unsigned long long;\n\ntemplate<typename T>\nconstexpr T power(T a, u64 b) {\n    T res {1};\n    for (; b != 0; b /= 2, a *= a) {\n        if (b % 2 == 1) {\n            res *= a;\n        }\n    }\n    return res;\n}\n \ntemplate<u32 P>\nconstexpr u32 mulMod(u32 a, u32 b) {\n    return 1ULL * a * b % P;\n}\n \ntemplate<u64 P>\nconstexpr u64 mulMod(u64 a, u64 b) {\n    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;\n    res %= P;\n    return res;\n}\n \ntemplate<typename U, U P>\nrequires std::unsigned_integral<U>\nstruct ModIntBase {\npublic:\n    constexpr ModIntBase() : x {0} {}\n     \n    template<typename T>\n    requires std::integral<T>\n    constexpr ModIntBase(T x_) : x {norm(x_ % T {P})} {}\n     \n    constexpr static U norm(U x) {\n        if ((x >> (8 * sizeof(U) - 1) & 1) == 1) {\n            x += P;\n        }\n        if (x >= P) {\n            x -= P;\n        }\n        return x;\n    }\n     \n    constexpr U val() const {\n        return x;\n    }\n     \n    constexpr ModIntBase operator-() const {\n        ModIntBase res;\n        res.x = norm(P - x);\n        return res;\n    }\n     \n    constexpr ModIntBase inv() const {\n        return power(*this, P - 2);\n    }\n     \n    constexpr ModIntBase &operator*=(const ModIntBase &rhs) & {\n        x = mulMod<P>(x, rhs.val());\n        return *this;\n    }\n     \n    constexpr ModIntBase &operator+=(const ModIntBase &rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n     \n    constexpr ModIntBase &operator-=(const ModIntBase &rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n     \n    constexpr ModIntBase &operator/=(const ModIntBase &rhs) & {\n        return *this *= rhs.inv();\n    }\n     \n    friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase &rhs) {\n        lhs *= rhs;\n        return lhs;\n    }\n     \n    friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase &rhs) {\n        lhs += rhs;\n        return lhs;\n    }\n     \n    friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase &rhs) {\n        lhs -= rhs;\n        return lhs;\n    }\n     \n    friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase &rhs) {\n        lhs /= rhs;\n        return lhs;\n    }\n     \n    friend constexpr std::ostream &operator<<(std::ostream &os, const ModIntBase &a) {\n        return os << a.val();\n    }\n     \n    friend constexpr bool operator==(ModIntBase lhs, ModIntBase rhs) {\n        return lhs.val() == rhs.val();\n    }\n     \n    friend constexpr bool operator!=(ModIntBase lhs, ModIntBase rhs) {\n        return lhs.val() != rhs.val();\n    }\n     \n    friend constexpr bool operator<(ModIntBase lhs, ModIntBase rhs) {\n        return lhs.val() < rhs.val();\n    }\n     \nprivate:\n    U x;\n};\n \ntemplate<u32 P>\nusing ModInt = ModIntBase<u32, P>;\n \ntemplate<u64 P>\nusing ModInt64 = ModIntBase<u64, P>;\n \nconstexpr u32 P = 998244353;\nusing Z = ModInt<P>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;"
  },
  "DS": {
    "SegmentTree.cpp": "template<class Info>\nstruct SegmentTree {\n    int n;\n    std::vector<Info> info;\n    SegmentTree() : n(0) {}\n    SegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    SegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << std::__lg(n), Info());\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = findFirst(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        int res = findLast(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = findLast(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n, l, r, pred);\n    }\n};\n\n/**\n * Hints:\n *      1. don't forget to set default value (T variable = value)\n *      2. use Info or const Info& in operator+\n */\nstruct Info {\n    int x = 0;\n};\n\n// use Info or const Info &\nInfo operator+(const Info &a, const Info &b) {\n    return Info{a.x + b.x};\n}",
    "Rmq.cpp": "template <typename T, class Compare = std::less<T>> class RangeMinQuery : private Compare {\n\tstatic const int BUCKET_SIZE = 32;\n\tstatic const int BUCKET_SIZE_LOG = 5;\n\tstatic_assert(BUCKET_SIZE == (1 << BUCKET_SIZE_LOG), \"BUCKET_SIZE should be a power of 2\");\n\tstatic const int CACHE_LINE_ALIGNMENT = 64;\n\tint n = 0;\n\tstd::vector<T> data;\n\tstd::vector<T> pref_data;\n\tstd::vector<T> suff_data;\n\tstd::vector<T> sparse_table;\n\tstd::vector<uint32_t> range_mask;\n\nprivate:\n\tint num_buckets() const {\n\t\treturn n >> BUCKET_SIZE_LOG;\n\t}\n\tint num_levels() const {\n\t\treturn num_buckets() ? 32 - __builtin_clz(num_buckets()) : 0;\n\t}\n\tint sparse_table_size() const {\n\t\treturn num_buckets() * num_levels();\n\t}\nprivate:\n\tconst T& min(const T& a, const T& b) const {\n\t\treturn Compare::operator()(a, b) ? a : b;\n\t}\n\tvoid setmin(T& a, const T& b) const {\n\t\tif (Compare::operator()(b, a)) a = b;\n\t}\n\n\ttemplate <typename Vec> static int get_size(const Vec& v) { using std::size; return int(size(v)); }\n\npublic:\n\tRangeMinQuery() {}\n\ttemplate <typename Vec> explicit RangeMinQuery(const Vec& data_, const Compare& comp_ = Compare())\n\t\t: Compare(comp_)\n\t\t, n(get_size(data_))\n\t\t, data(n)\n\t\t, pref_data(n)\n\t\t, suff_data(n)\n\t\t, sparse_table(sparse_table_size())\n\t\t, range_mask(n)\n\t{\n\t\tfor (int i = 0; i < n; i++) data[i] = data_[i];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i & (BUCKET_SIZE-1)) {\n\t\t\t\tuint32_t m = range_mask[i-1];\n\t\t\t\twhile (m && !Compare::operator()(data[(i | (BUCKET_SIZE-1)) - __builtin_clz(m)], data[i])) {\n\t\t\t\t\tm -= uint32_t(1) << (BUCKET_SIZE - 1 - __builtin_clz(m));\n\t\t\t\t}\n\t\t\t\tm |= uint32_t(1) << (i & (BUCKET_SIZE - 1));\n\t\t\t\trange_mask[i] = m;\n\t\t\t} else {\n\t\t\t\trange_mask[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpref_data[i] = data[i];\n\t\t\tif (i & (BUCKET_SIZE-1)) {\n\t\t\t\tsetmin(pref_data[i], pref_data[i-1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\tsuff_data[i] = data[i];\n\t\t\tif (i+1 < n && ((i+1) & (BUCKET_SIZE-1))) {\n\t\t\t\tsetmin(suff_data[i], suff_data[i+1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < num_buckets(); i++) {\n\t\t\tsparse_table[i] = data[i * BUCKET_SIZE];\n\t\t\tfor (int v = 1; v < BUCKET_SIZE; v++) {\n\t\t\t\tsetmin(sparse_table[i], data[i * BUCKET_SIZE + v]);\n\t\t\t}\n\t\t}\n\t\tfor (int l = 0; l+1 < num_levels(); l++) {\n\t\t\tfor (int i = 0; i + (1 << (l+1)) <= num_buckets(); i++) {\n\t\t\t\tsparse_table[(l+1) * num_buckets() + i] = min(sparse_table[l * num_buckets() + i], sparse_table[l * num_buckets() + i + (1 << l)]);\n\t\t\t}\n\t\t}\n\t}\n\n\tT query(int l, int r) const {\n\t\tassert(l <= r);\n\t\tint bucket_l = (l >> BUCKET_SIZE_LOG);\n\t\tint bucket_r = (r >> BUCKET_SIZE_LOG);\n\t\tif (bucket_l == bucket_r) {\n\t\t\tuint32_t msk = range_mask[r] & ~((uint32_t(1) << (l & (BUCKET_SIZE-1))) - 1);\n\t\t\tint ind = (l & ~(BUCKET_SIZE-1)) + __builtin_ctz(msk);\n\t\t\treturn data[ind];\n\t\t} else {\n\t\t\tT ans = min(suff_data[l], pref_data[r]);\n\t\t\tbucket_l++;\n\t\t\tif (bucket_l < bucket_r) {\n\t\t\t\tint level = (32 - __builtin_clz(bucket_r - bucket_l)) - 1;\n\t\t\t\tsetmin(ans, sparse_table[level * num_buckets() + bucket_l]);\n\t\t\t\tsetmin(ans, sparse_table[level * num_buckets() + bucket_r - (1 << level)]);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\ntemplate <typename T> using RangeMaxQuery = RangeMinQuery<T, std::greater<T>>;",
    "LazyHeap.cpp": "template<typename T, typename Compare = less<T>>\nclass LazyHeap {\n    priority_queue<T, vector<T>, Compare> pq;\n    unordered_map<T, int> remove_cnt; // 每个元素剩余需要删除的次数\n    size_t sz = 0; // 实际大小\n    long long s = 0; // 堆中元素总和\n\n    // 正式执行删除操作\n    void apply_remove() {\n        while (!pq.empty() && remove_cnt[pq.top()] > 0) {\n            remove_cnt[pq.top()]--;\n            pq.pop();\n        }\n    }\n\npublic:\n    size_t size() {\n        return sz;\n    }\n\n    long long sum() {\n        return s;\n    }\n\n    // 删除\n    void remove(T x) {\n        remove_cnt[x]++; // 懒删除\n        sz--;\n        s -= x;\n    }\n\n    // 查看堆顶\n    T top() {\n        apply_remove();\n        return pq.top();\n    }\n\n    // 出堆\n    T pop() {\n        apply_remove();\n        T x = pq.top();\n        pq.pop();\n        sz--;\n        s -= x;\n        return x;\n    }\n\n    // 入堆\n    void push(T x) {\n        if (remove_cnt[x] > 0) {\n            remove_cnt[x]--; // 抵消之前的删除\n        } else {\n            pq.push(x);\n        }\n        sz++;\n        s += x;\n    }\n\n    // push(x) 然后 pop()\n    T push_pop(T x) {\n        apply_remove();\n        pq.push(x);\n        s += x;\n        x = pq.top();\n        pq.pop();\n        s -= x;\n        return x;\n    }\n};",
    "DSU.cpp": "struct DSU {\n    std::vector<int> f, siz;\n     \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n     \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n     \n    int find(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n     \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n     \n    bool merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n     \n    int size(int x) {\n        return siz[find(x)];\n    }\n};",
    "Fenwick.cpp": "template <typename T>\nstruct Fenwick {\n    int n;\n    std::vector<T> a;\n    \n    Fenwick(int n_ = 0) {\n        init(n_);\n    }\n    \n    void init(int n_) {\n        n = n_;\n        a.assign(n, T{});\n    }\n    \n    void add(int x, const T &v) {\n        for (int i = x + 1; i <= n; i += i & -i) {\n            a[i - 1] = a[i - 1] + v;\n        }\n    }\n    \n    T sum(int x) {\n        T ans{};\n        for (int i = x; i > 0; i -= i & -i) {\n            ans = ans + a[i - 1];\n        }\n        return ans;\n    }\n    \n    T rangeSum(int l, int r) {\n        return sum(r) - sum(l);\n    }\n    \n    int select(const T &k) {\n        int x = 0;\n        T cur{};\n        for (int i = 1 << std::__lg(n); i; i /= 2) {\n            if (x + i <= n && cur + a[x + i - 1] <= k) {\n                x += i;\n                cur = cur + a[x - 1];\n            }\n        }\n        return x;\n    }\n};\n\n// don't forget to set default value\n// T variable = value\nstruct Info{\n    int x;\n    Info(int x_ = 0):x(x_) {}\n};\nInfo operator+(const Info &a, const Info &b) {\n    return Info{max(a.x, b.x)};\n}",
    "LazySegmentTree.cpp": "template <class Info, class Tag>\nstruct LazySegmentTree {\n    const int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree(int n) : n(n), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}\n    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n};\n\n\n/**\n * Hints:\n *      1. don't forget to set default value (T variable = value)\n *      2. use Info or const Info& in operator+\n */\nstruct Tag {\n    int x = 0;\n \n    void apply(const Tag &t) {\n        x += t.x;\n    }\n};\nstruct Info {\n    int x = 0;\n \n    void apply(const Tag &t) {\n        x += t.x;\n    }\n};\nInfo operator+(const Info &a, const Info &b) {\n    return Info{a.x + b.x};\n}",
    "xorTrie.cpp": "/**\n * https://github.com/Joshc88/CPTemplates/blob/main/Math/xortrie.h\n*/\ntemplate <class T = int>\nstruct xortrie {\n    vector<array<int, 2>> trie = {{0, 0}};\n    vector<int> cnt = {0};\n    int NUM_BITS = 31;\n\n    xortrie() {}\n\n    xortrie(int bits, int elements = -1) {\n        NUM_BITS = bits;\n        if (elements != -1) {\n            trie.reserve(elements * bits);\n            cnt.reserve(elements * bits);\n        }\n    }\n\n    void update(T val, int delta) {\n        int node = 0;\n        for (int i = NUM_BITS - 1; i >= 0; i--) {\n            int c = val & (1ll << i) ? 1 : 0;\n            if (!trie[node][c]) {\n                trie[node][c] = trie.size();\n                trie.push_back({0, 0});\n                cnt.push_back(0);\n            }\n            node = trie[node][c];\n            cnt[node] += delta;\n        }\n    }\n\n    void insert(T val) { update(val, 1); }\n\n    void erase(T val) { update(val, -1); }\n\n    T max(T val) {\n        // Find max of val XOR element\n        T res = 0;\n        int node = 0;\n        for (int i = NUM_BITS - 1; i >= 0; i--) {\n            int c = val & (1ll << i) ? 0 : 1;\n            if (trie[node][c] && cnt[trie[node][c]]) {\n                res ^= 1ll << i;\n                node = trie[node][c];\n            } else\n                node = trie[node][c ^ 1];\n        }\n        return res;\n    }\n\n    T min(T val) {\n        // Find min of val XOR element\n        T res = 0;\n        int node = 0;\n        for (int i = NUM_BITS - 1; i >= 0; i--) {\n            int c = val & (1ll << i) ? 1 : 0;\n            if (trie[node][c] && cnt[trie[node][c]])\n                node = trie[node][c];\n            else {\n                res ^= 1ll << i;\n                node = trie[node][c ^ 1];\n            }\n        }\n        return res;\n    }\n\n    int less_than(T val, T limit) {\n        // How many elements satisfy val XOR element < limit ?\n        int res = 0, node = 0;\n        for (int i = NUM_BITS - 1; i >= 0; i--) {\n            int c = val & (1ll << i) ? 1 : 0;\n            if (limit & (1ll << i)) {\n                res += cnt[trie[node][c]];\n                if (trie[node][c ^ 1] && cnt[trie[node][c ^ 1]])\n                    node = trie[node][c ^ 1];\n                else\n                    break;\n            } else {\n                if (trie[node][c] && cnt[trie[node][c]])\n                    node = trie[node][c];\n                else\n                    break;\n            }\n        }\n        return res;\n    }\n};",
    "SparseTable.cpp": "/**\n * https://github.com/the-tourist/algo/blob/master/data/sparsetable.cpp\n */\ntemplate <typename T, typename F>\nclass SparseTable {\n   public:\n    int n;\n    vector<vector<T>> mat;\n    F func;\n\n    SparseTable(const vector<T>& a, const F& f) : func(f) {\n        n = static_cast<int>(a.size());\n        int max_log = 32 - __builtin_clz(n);\n        mat.resize(max_log);\n        mat[0] = a;\n        for (int j = 1; j < max_log; j++) {\n            mat[j].resize(n - (1 << j) + 1);\n            for (int i = 0; i <= n - (1 << j); i++) {\n                mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n            }\n        }\n    }\n\n    T query(int from, int to) const {\n        assert(0 <= from && from <= to && to <= n - 1);\n        int lg = 32 - __builtin_clz(to - from + 1) - 1;\n        return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n    }\n};\n\nauto get_max = [](auto a, auto b) { return max(a, b); };\n\nauto get_min = [](auto a, auto b) { return min(a, b); };\n\n// SparseTable<int, decltype(get_max)> st(input_data, get_max);",
    "MatrixSum.cpp": "class MatrixSum {\nprivate:\n    vector<vector<int>> sum;\n\npublic:\n    MatrixSum(vector<vector<int>> &matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        sum = vector<vector<int>>(m + 1, vector<int>(n + 1));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + matrix[i][j];\n            }\n        }\n    }\n\n    // 左闭，右开  左上角(x1,y1) 右下角(x2 - 1,y2 - 1)\n    int query(int x1, int y1, int x2, int y2) {\n        return sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1];\n    }\n};"
  }
}