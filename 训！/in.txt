// pdd.2
void solve() {
    int m, n;
    cin >> m >> n;
    string a, b;
    cin >> a >> b;
    
    // 1的数量为偶数
    // 不同的位置为偶数
    unordered_set<string> uni;
    for (int i = 0; i + n <= m; i++) {
        int diff = 0;
        for (int j = 0; j < n; j++) {
            if (a[i + j] != b[j]) {
                diff++;
            }
        }
        if (diff % 2 == 0) {
            uni.insert(a.substr(i, n));
        }
    }
    cout << uni.size() << endl;
}

// pdd.5
def main():
    s = I()
    n = len(s)

    # dp(i, j) [i, j]变成回文串的最少操作次数
    @lru_cache
    def dp(i:int, j:int) -> int:
        if i + 1 >= j:
            return s[i] != s[j]

        if s[i] == s[j]:
            return dp(i + 1, j - 1)
        r = inf
        for k in range(i, j):
            r = min(r, dp(i, k) + dp(k + 1, j) + 1)
        return r
    print(dp(0, n - 1) + 1)

// aliyun.1
def main():
    n = II()
    a = []
    for _ in range(n):
        r, g = MII()
        a.append((r, g))
    dp = [[0] * 3 for _ in range(n + 1)]

    for i in range(n):
        r, g = a[i]
        dp[i + 1][0] = max(dp[i + 1][0], max(dp[i][1], dp[i][2]) + r);
        dp[i + 1][1] = max(dp[i + 1][1], max(dp[i][0], dp[i][2]) + g);
        dp[i + 1][2] = max(dp[i + 1][2], max(dp[i][1], dp[i][2]));
    print(max(dp[-1]))

// taotian.1
def main():
    n, m = MII()
    a = LII()
    b = LII()
    mx = max(a)
    heapify(a)
    for x in b:
        val = heappop(a)
        val += x
        mx = max(mx, val)
        heappush(a, val)
        print(mx)