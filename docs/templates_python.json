{
  "root": {
    "Comb.py": "class Combinatorics:\n    def __init__(self, n, mod):\n        assert mod > n\n        self.n = n + 10\n        self.mod = mod\n\n        self.perm = [1]\n        self.rev = [1]\n        self.inv = [0]\n        self.fault = [0]\n\n        self.build_perm()\n        self.build_rev()\n        self.build_inv()\n        self.build_fault()\n        return\n\n    def build_perm(self):\n        self.perm = [1] * (self.n + 1)  # (i!) % mod\n        for i in range(1, self.n + 1):\n            self.perm[i] = self.perm[i - 1] * i % self.mod\n        return\n\n    def build_rev(self):\n        self.rev = [1] * (self.n + 1)  # pow(i!, -1, mod)\n        self.rev[-1] = pow(self.perm[-1], -1, self.mod)  # GcdLike().mod_reverse(self.perm[-1], self.mod)\n        for i in range(self.n - 1, 0, -1):\n            self.rev[i] = (self.rev[i + 1] * (i + 1) % self.mod)  # pow(i!, -1, mod)\n        return\n\n    def build_inv(self):\n        self.inv = [0] * (self.n + 1)  # pow(i, -1, mod)\n        self.inv[1] = 1\n        for i in range(2, self.n + 1):\n            self.inv[i] = (self.mod - self.mod // i) * self.inv[self.mod % i] % self.mod\n        return\n\n    def build_fault(self):\n        self.fault = [0] * (self.n + 1)  # fault permutation\n        self.fault[0] = 1\n        self.fault[2] = 1\n        for i in range(3, self.n + 1):\n            self.fault[i] = (i - 1) * (self.fault[i - 1] + self.fault[i - 2])\n            self.fault[i] %= self.mod\n        return\n\n    def comb(self, a, b):\n        if a < b:\n            return 0\n        res = self.perm[a] * self.rev[b] * self.rev[a - b]  # comb(a, b) % mod = (a!/(b!(a-b)!)) % mod\n        return res % self.mod\n\n    def factorial(self, a):\n        res = self.perm[a]  # (a!) % mod\n        return res % self.mod\n\n    def inverse(self, n):\n        res = self.perm[n - 1] * self.rev[n] % self.mod  # pow(n, -1, mod)\n        return res\n\n    def catalan(self, n):\n        res = (self.comb(2 * n, n) - self.comb(2 * n, n - 1)) % self.mod\n        return res\n\n",
    "DSU.py": "from collections import defaultdict\nclass DSU:\n    def __init__(self, n: int) -> None:\n        self.root_or_size = [-1] * n\n        self.part = n\n        self.n = n\n        return\n\n    def initialize(self):\n        for i in range(self.n):\n            self.root_or_size[i] = -1\n        self.part = self.n\n        return\n\n    def find(self, x):\n        y = x\n        while self.root_or_size[x] >= 0:\n            # range_merge_to_disjoint to the direct root node after query\n            x = self.root_or_size[x]\n        while y != x:\n            self.root_or_size[y], y = x, self.root_or_size[y]\n        return x\n\n    def merge(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if self.root_or_size[root_x] < self.root_or_size[root_y]:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return True\n\n    def merge_left(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        self.root_or_size[root_x] += self.root_or_size[root_y]\n        self.root_or_size[root_y] = root_x\n        self.part -= 1\n        return True\n\n    def merge_right(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return True\n\n    def merge_max(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if root_x > root_y:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return\n\n    def merge_min(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return False\n        if root_x < root_y:\n            root_x, root_y = root_y, root_x\n        self.root_or_size[root_y] += self.root_or_size[root_x]\n        self.root_or_size[root_x] = root_y\n        self.part -= 1\n        return\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.root_or_size[self.find(x)]\n\n    def get_root_part(self):\n        # get the nodes list of every root\n        part = defaultdict(list)\n        n = len(self.root_or_size)\n        for i in range(n):\n            part[self.find(i)].append(i)\n        return part\n\n    def get_root_size(self):\n        # get the size of every root\n        size = defaultdict(int)\n        n = len(self.root_or_size)\n        for i in range(n):\n            if self.find(i) == i:\n                size[i] = -self.root_or_size[i]\n        return size\n",
    "Fenwick.py": "import typing\n\n\nclass Fenwick:\n    '''Reference: https://en.wikipedia.org/wiki/Fenwick_tree'''\n\n    def __init__(self, n: int = 0) -> None:\n        self._n = n\n        self.data = [0] * n\n\n    def add(self, p: int, x: typing.Any) -> None:\n        assert 0 <= p < self._n\n\n        p += 1\n        while p <= self._n:\n            self.data[p - 1] += x\n            p += p & -p\n\n    def rangeSum(self, left: int, right: int) -> typing.Any:\n        assert 0 <= left <= right <= self._n\n\n        return self.sum(right) - self.sum(left)\n\n    def sum(self, r: int) -> typing.Any:\n        s = 0\n        while r > 0:\n            s += self.data[r - 1]\n            r -= r & -r\n\n        return s",
    "IO_Python.py": "standard_input, packages, output_together = 1, 1, 0\ndfs, hashing, read_from_file = 0, 0, 0\nde = 1\n\nif 1:\n\n    if standard_input:\n        import io, os, sys\n        input = lambda: sys.stdin.readline().strip()\n\n        import math\n        inf = math.inf\n\n        def I():\n            return input()\n        \n        def II():\n            return int(input())\n\n        def MII():\n            return map(int, input().split())\n\n        def LI():\n            return input().split()\n\n        def LII():\n            return list(map(int, input().split()))\n\n        def LFI():\n            return list(map(float, input().split()))\n\n        def GMI():\n            return map(lambda x: int(x) - 1, input().split())\n\n        def LGMI():\n            return list(map(lambda x: int(x) - 1, input().split()))\n\n    if packages:\n        from io import BytesIO, IOBase\n\n        import random\n        import os\n\n        import bisect\n        import typing\n        from collections import Counter, defaultdict, deque\n        from copy import deepcopy\n        from functools import cmp_to_key, lru_cache, reduce\n        from heapq import merge, heapify, heappop, heappush, heappushpop, nlargest, nsmallest\n        from itertools import accumulate, combinations, permutations, count, product\n        from operator import add, iand, ior, itemgetter, mul, xor\n        from string import ascii_lowercase, ascii_uppercase, ascii_letters\n        from typing import *\n        BUFSIZE = 4096\n\n    if output_together:\n        class FastIO(IOBase):\n            newlines = 0\n\n            def __init__(self, file):\n                self._fd = file.fileno()\n                self.buffer = BytesIO()\n                self.writable = \"x\" in file.mode or \"r\" not in file.mode\n                self.write = self.buffer.write if self.writable else None\n\n            def read(self):\n                while True:\n                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n                    if not b:\n                        break\n                    ptr = self.buffer.tell()\n                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n                self.newlines = 0\n                return self.buffer.read()\n\n            def readline(self):\n                while self.newlines == 0:\n                    b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n                    self.newlines = b.count(b\"\\n\") + (not b)\n                    ptr = self.buffer.tell()\n                    self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n                self.newlines -= 1\n                return self.buffer.readline()\n\n            def flush(self):\n                if self.writable:\n                    os.write(self._fd, self.buffer.getvalue())\n                    self.buffer.truncate(0), self.buffer.seek(0)\n\n        class IOWrapper(IOBase):\n            def __init__(self, file):\n                self.buffer = FastIO(file)\n                self.flush = self.buffer.flush\n                self.writable = self.buffer.writable\n                self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n                self.read = lambda: self.buffer.read().decode(\"ascii\")\n                self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n        sys.stdout = IOWrapper(sys.stdout)\n\n    if dfs:\n        from types import GeneratorType\n\n        def bootstrap(f, stk=[]):\n            def wrappedfunc(*args, **kwargs):\n                if stk:\n                    return f(*args, **kwargs)\n                else:\n                    to = f(*args, **kwargs)\n                    while True:\n                        if type(to) is GeneratorType:\n                            stk.append(to)\n                            to = next(to)\n                        else:\n                            stk.pop()\n                            if not stk:\n                                break\n                            to = stk[-1].send(to)\n                    return to\n            return wrappedfunc\n\n    if hashing:\n        RANDOM = random.getrandbits(20)\n        class Wrapper(int):\n            def __init__(self, x):\n                int.__init__(x)\n\n            def __hash__(self):\n                return super(Wrapper, self).__hash__() ^ RANDOM\n\n    if read_from_file:\n        file = open(\"input.txt\", \"r\").readline().strip()[1:-1]\n        fin = open(file, 'r')\n        input = lambda: fin.readline().strip()\n        output_file = open(\"output.txt\", \"w\")\n        def fprint(*args, **kwargs):\n            print(*args, **kwargs, file=output_file)\n\n    if de:\n        def debug(*args, **kwargs):\n            print('\\033[92m', end='')\n            print(*args, **kwargs)\n            print('\\033[0m', end='')\n\n    fmax = lambda x, y: x if x > y else y\n    fmin = lambda x, y: x if x < y else y\n\n    class lst_lst:\n        def __init__(self, n) -> None:\n            self.n = n\n            self.pre = []\n            self.cur = []\n            self.lst = [-1] * n\n        \n        def append(self, i, j):\n            self.pre.append(self.lst[i])\n            self.lst[i] = len(self.cur)\n            self.cur.append(j)\n        \n        def iterate(self, i):\n            tmp = self.lst[i]\n            while tmp != -1:\n                yield self.cur[tmp]\n                tmp = self.pre[tmp]\n'''\n> File Name: ${1:${TM_FILENAME}}\n> Author: Wu YiFan\n> Github: https://github.com/wyf0722\n> Mail: wyf0722chosen@gmail.com\n> Created Time: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}\n'''\nMULTITEST = 1\nMOD = 1_000_000_007\ndef main():\n    pass\n\nT = 1\nif MULTITEST:\n    T = II()\nfor _ in range(T):\n    main()",
    "Math.py": "\"\"\"\n埃氏筛\n\"\"\"\nMX = 10**5 + 10\nprime = []\nis_prime = [True] * (MX + 1)\nis_prime[0] = is_prime[1] = False\nfor i in range(2, MX + 1):\n    if is_prime[i]:\n        prime.append(i)\n        for j in range(i * i, MX + 1, i):\n            is_prime[j] = False\n\n'''\n组合数\n'''\nMOD = 998244353\nN = 1000\nfac = [1]\nfor i in range(1, N + 1):\n    fac.append(fac[-1] * i % MOD)\nfac_inv = [1] * (N + 1)\nfac_inv[N] = pow(fac[N], MOD - 2, MOD)\nfor i in range(N - 1, 0, -1):\n    fac_inv[i] = fac_inv[i + 1] * (i + 1) % MOD\ndef Comb(n:int, m:int) -> int:\n    assert n >= m and n >= 0 and m >= 0\n    return fac[n] * fac_inv[m] % MOD * fac_inv[n - m] % MOD",
    "Prime.py": "class PrimeFactor:\n    def __init__(self, n):\n        self.n = n\n        # calculate the minimum prime factor for all numbers from 1 to self.n\n        self.min_prime = [0] * (self.n + 1)\n        # determine whether all numbers from 1 to self.n are prime numbers\n        self.is_prime = [0] * (self.n + 1)\n        # calculate the prime factorization of all numbers from 1 to self.n\n        self.prime_factor = [[] for _ in range(self.n + 1)]\n        # calculate all factors of all numbers from 1 to self.n, including 1 and the number itself\n        self.all_factor = [[], [1]] + [[1, i] for i in range(2, self.n + 1)]\n        self.build()\n        return\n\n    def build(self):\n\n        # complexity is O(nlogn)\n        for i in range(2, self.n + 1):\n            if not self.min_prime[i]:\n                self.is_prime[i] = 1\n                self.min_prime[i] = i\n                for j in range(i * i, self.n + 1, i):\n                    if not self.min_prime[j]:\n                        self.min_prime[j] = i\n\n        # complexity is O(nlogn)\n        for num in range(2, self.n + 1):\n            i = num\n            while num > 1:\n                p = self.min_prime[num]\n                cnt = 0\n                while num % p == 0:\n                    num //= p\n                    cnt += 1\n                self.prime_factor[i].append((p, cnt))\n\n        # complexity is O(nlogn)\n        for i in range(2, self.n + 1):\n            x = i\n            while x * i <= self.n:\n                self.all_factor[x * i].append(i)\n                if i != x:\n                    self.all_factor[x * i].append(x)\n                x += 1\n        for i in range(self.n + 1):\n            self.all_factor[i].sort()\n        return\n\n    def comb(self, a, b):\n        # Use prime factor decomposition to solve the values of combinatorial mathematics\n        # and prime factor decomposition O ((a+b) log (a+b))\n        cnt = defaultdict(int)\n        for i in range(1, a + 1):  # a!\n            for num, y in self.prime_factor[i]:\n                cnt[num] += y\n        for i in range(1, b + 1):  # b!\n            for num, y in self.prime_factor[i]:\n                cnt[num] -= y\n        for i in range(1, a - b + 1):  # (a-b)!\n            for num, y in self.prime_factor[i]:\n                cnt[num] -= y\n        ans = 1\n        for w in cnt:\n            ans *= w ** cnt[w]\n        return ans\n\n    def get_prime_numbers(self):\n        return [i for i in range(1, self.n + 1) if self.is_prime[i]]"
  }
}